#!/usr/bin/perl

use strict;
use utf8;
use warnings;

use Scalar::Util qw(looks_like_number);

no warnings 'utf8';

our $SRC = "data/IdnaTest.txt";
open IdnaTest, '<', $SRC || die "cannot open $SRC: $!";
binmode IdnaTest, ':utf8';

my @tests;

while(<IdnaTest>) {
  chomp; 
  s/\s*#.*//; next if !m/\S/;

  my @c = ($., split /;/);
  foreach(@c) { s/^\s+//; s/\s+$//; }; 
  die "format error: '$_' $#c <@c>" if $#c < 4;
  die "unknown test type: $c[1]" if $c[1] !~ m/^(B|N|T)$/;
  
  push @tests, \@c;
}

die "no tests" unless @tests;

our $DATA = "data/IdnaMappingTable.txt";
open IdnaMappingTable, '<', $DATA || die "cannot open $SRC: $!";
binmode IdnaMappingTable, ':utf8';

our @ucd_ver;

while(<IdnaMappingTable>) {
  chomp; 
  m/([[:xdigit:]]{4,})(?:\.+([[:xdigit:]]{4,}))?\s*;[^#]*#\s*([[:digit:]]+\.[[:digit:]]+|NA)\b/i or next;
  my($from,$to,$ucd_ver) = ($1, $2, $3);
  $to = $from if !defined $to;
  $from = hex $from;
  $to   = hex $to;

  $ucd_ver = looks_like_number($ucd_ver) 
    ? join '', map { chr $_ } split /\./, $ucd_ver
    : undef;

  $ucd_ver[$_] = $ucd_ver foreach ($from..$to);
}

write_test('', 		'unicode', 3, { 'TransitionalProcessing' => 0, }, @tests);
write_test('', 		'ascii', , 4, { 'TransitionalProcessing' => 0, }, grep { $_->[1] =~ m/B|N/ } @tests);
write_test('-trans',    'ascii', , 4, { 'TransitionalProcessing' => 1, }, grep { $_->[1] =~ m/B|T/ } @tests);
exit(0);

sub min_ucd {
  my $min_ucd = v1.0;
  foreach my $c (split //, shift) {
    my $ucd_ver_c = $ucd_ver[ord $c];
    return undef if !defined $ucd_ver_c;
    $min_ucd = $ucd_ver_c if $ucd_ver_c gt $min_ucd;
  }
  return $min_ucd;
}

sub write_test {
  my($type, $to, $column, $para, $min_perl) = splice @_,0,4;

  my $fn = "t/uts46_to_$to$type.t";

  print STDERR "generating $fn\n" if -t STDERR;

  open STDOUT, ">", $fn || die "cannot open $fn: $!";
  binmode STDOUT, ":utf8";
  
  my $c = $#_ + 1;

  print <<__EOF;
# *** DO NOT EDIT *** generated file *** DO NOT EDIT ***
#
# generated by $0 from $SRC
# see repository at http://github.com/cfaerber/Net-IDN-Encode for source files
#
use strict;
use utf8;
use open ':std', ':utf8';
use warnings;

use Test::More tests => $c + 1;
use Test::NoWarnings;

use Unicode::UCD;
use Net::IDN::UTS46 (':all');

no warnings 'utf8';

our \$UCD_VERSION = eval('v'.(Unicode::UCD::UnicodeVersion()));

__EOF
  print "my %p = (".qhash(%{$para}).");\n\n";

  foreach (@_) {
    $.       = $_->[0];
    my $src  = $_->[2];
    my $dest = $_->[$column];

    # my $src_u8  = parse_str($src);
    # my $dest_u8 = parse_str($dest);

    $dest = $_->[3] if $dest eq '' && $column != 3;
    $dest = $src if $dest eq '';
    my $err = undef;

    my $com = "to_$to('".$src."')";

    if($dest =~ m/^\[(.*)\]$/) {
      $dest = undef;
      $err = $1;
      $com .= " throws error $err";
    }

    my $l_u8 = join '-', map { parse_str($_) } @{$_};
    my ($min_ucd,$min_perl, $need_closing_bracket);

    $min_ucd = min_ucd($l_u8);

    if(!(defined($err) and ($err =~ m/P1/) and ($err =~ m/V6/)) and defined($min_ucd)) { ## should be invalid anyway

      my %unicode_to_perl_version = (
        v3.2	=> v5.8.0,
        v4.0	=> v5.8.1,
        v4.0.1	=> v5.8.4,
        v4.1	=> v5.8.7,
        v5.0	=> v5.9.5,
        v5.1	=> v5.10.1,
        v5.2	=> v5.11.5,
        v6.0	=> v5.13.7,
        v6.1	=> v5.15.8,
        v6.2	=> v5.17.1,
        v6.3	=> v5.19.5,
	v7.0	=> v5.21.1,
	v8.0	=> v5.24.0,
	v9.0	=> v5.25.3,
	v10.0	=> v5.28.0,
	v11.0	=> v5.29.2,
      );

      $min_perl = ($min_ucd lt v4) ? v5.8.0 : $unicode_to_perl_version{$min_ucd} or die sprintf "don't know perl version required for Unicode %vd", $min_ucd;

      if ($min_perl gt v5.8.5) {	# 5.8.5 required by Net::IDN::UTS46
        print 'SKIP: { skip sprintf("requires UnicodeÂ® ',sprintf('v%vd', $min_ucd),
	  ' (perl ',sprintf('v%vd', $min_perl),') or higher,',
  	  ' only v%vd is supported (perl v%vd)", $UCD_VERSION, $^V)',
  	  ', 1 if $UCD_VERSION lt ',sprintf('v%vd', $min_ucd),'; ';
	$need_closing_bracket++;
      }
    } # unless 

    $com =~ s/\p{C}/?/g;
    $com .= " [$SRC:$.]";
    print "is(eval{uts46_to_$to(", qstr($src), ", %p)},\t", qstr($dest), ',', "\t", '"', quotemeta($com), '"', ")",' or ($@ and diag($@))',";";

    if(defined $need_closing_bracket) {
      print ' }';
    }

    print "\n";
  }
  print "\n\nexit(0);\n";

  close STDOUT;
}

sub qhash {
  my %h = @_; my $s = '';
  foreach(sort keys %h) {
    $s .= ', ' if $s;
    $s .= qstr($_);
    $s .= ' => '.qstr($h{$_});
  }
  return $s;
}

sub parse_str {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/\\u(D[89AB][[:xdigit:]]{2})\\u(D[CDEF][[:xdigit:]]{2})/ chr(0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\u([[:xdigit:]]{4})/ chr(hex $1) /gei;
  return $s;
}

sub qstr {
  my $s = shift;
  return 'undef' if !defined $s;
  $s =~ s/([\\\$\@\"])/\\$1/g;
  $s =~ s/\\\\u(D[89AB][[:xdigit:]]{2})\\\\u(D[CDEF][[:xdigit:]]{2})/
	sprintf('\x{%04X}', 0x10000 + (hex($1)&0x3FF)*0x400 + (hex($2)&0x3FF)) /gei;
  $s =~ s/\\\\u([[:xdigit:]]{4})/\\x{$1}/gi;
  return '"'. $s. '"';
}
